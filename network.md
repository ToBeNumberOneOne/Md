在Socket API编程中，应用程序通过系统调用与TCP协议层交互，TCP协议层则负责实际的连接管理、数据传输和状态维护。以下是客户端和服务端在连接（三次握手）和断开（四次挥手）过程中的状态流转及交互细节：

---

### **一、建立连接（三次握手）**
#### **1. 客户端流程**
- **应用程序调用** `connect()`
  客户端发起连接请求，TCP协议层发送`SYN`报文（同步序列号）。
- **客户端状态流转**：
  `CLOSED` → `SYN_SENT`（发送`SYN`后等待服务端响应）。

#### **2. 服务端流程**
- **应用程序调用** `listen()`
  服务端进入监听状态，等待客户端连接。
- **服务端状态流转**：
  `CLOSED` → `LISTEN`（被动打开，准备接收`SYN`）。

- **当收到`SYN`时**：
  TCP协议层回复`SYN-ACK`，状态变为`SYN_RCVD`（等待客户端`ACK`）。

#### **3. 三次握手完成**
- **客户端收到`SYN-ACK`**：
  TCP协议层发送`ACK`，状态变为`ESTABLISHED`（连接已建立）。
- **服务端收到`ACK`**：
  状态从`SYN_RCVD`变为`ESTABLISHED`。

**关键点**：
- 握手由内核协议栈自动完成，应用程序仅在`connect()`和`accept()`处阻塞/返回。
- `accept()`从已完成连接队列（`ESTABLISHED`状态的socket）中取出一个连接。

---

### **二、断开连接（四次挥手）**
#### **1. 主动关闭方（如客户端）**
- **应用程序调用** `close()`
  TCP协议层发送`FIN`报文，表示不再发送数据。
- **状态流转**：
  `ESTABLISHED` → `FIN_WAIT_1`（等待对方确认`FIN`）。

- **收到服务端的`ACK`**：
  状态变为`FIN_WAIT_2`（等待服务端的`FIN`）。

- **收到服务端的`FIN`**：
  发送`ACK`，状态变为`TIME_WAIT`（等待2MSL确保对方收到`ACK`）。

#### **2. 被动关闭方（如服务端）**
- **收到`FIN`时**：
  TCP协议层回复`ACK`，状态变为`CLOSE_WAIT`（等待应用程序调用`close()`）。

- **应用程序调用** `close()`：
  发送`FIN`，状态变为`LAST_ACK`（等待最后的`ACK`）。

- **收到客户端的`ACK`**：
  状态变为`CLOSED`。

**关键点**：
- `TIME_WAIT`状态持续2MSL（报文最大生存时间），防止最后一个`ACK`丢失导致连接残留。
- 如果服务端未及时调用`close()`，连接会停留在`CLOSE_WAIT`，可能导致资源泄漏。

---
